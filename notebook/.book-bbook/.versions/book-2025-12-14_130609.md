# Accueil

```julia (editor=true, logging=false, output=true)
using Makie, WGLMakie, Gtk, JSON3, DataFrames, Dates, VegaLite, GLMakie

# Dialogue sélection du fichier
#file_path = open_dialog("Sélectionnez un fichier Spotify (JSON)")
#file_path === nothing && error("Aucun fichier sélectionné.")
# Lecture fichier
#txt = read(file_path, String)
#txt = strip(txt)
txt = "examples/data/History_files/Streaming_History_Audio_2024-2025_2.json"
# Parse JSON
data = JSON3.read(txt)
# Conversion en dataframe
rows = [Dict{Symbol,Any}(Symbol(k) => v for (k, v) in pairs(obj)) for obj in data]
df = DataFrame(rows)

# Séparation de la date et de l'heure
# Conversion en DateTime
df.date_time_parsed = DateTime.(df.ts, dateformat"yyyy-mm-ddTHH:MM:SSZ")
# Séparation en deux colonnes
df.date = Date.(df.date_time_parsed)
df.time = Time.(df.date_time_parsed)

first(df,2)
```
```julia (editor=true, logging=false, output=true)
df = select(df, 
:master_metadata_track_name => :track_name, 
:master_metadata_album_album_name => :album,
:master_metadata_album_artist_name => :artist,
:date, :time,
:ms_played,
:skipped,
:reason_end,
:shuffle
)
first(df, 2)
```
# Temps d'écoute

## 0. Statistiques globales (minutes, heures, jours) (KPI)

```julia (editor=true, logging=false, output=true)
tps_min = sum(df.ms_played) / 60000  # en minutes
tps_h = tps_min / 60
tps_j = tps_h / 24

printstyled("Vous avez $(round(tps_min, digits = 2)) minutes d'écoute, soit $(round(tps_h, digits = 2)) heures, ou $(round(tps_j)) jours. Waouh !")
```
```julia (editor=false, logging=false, output=true)
printstyled("Vous avez écouté de la musiques pendant $(round(tps_min,digits=0)) minutes, soit $(round(tps_h,digits=0)) heures ou $(round(tps_j,digits=0)) jours !")
```
## 1. Répartition sur les mois (bar chart)

```julia (editor=true, logging=false, output=true)
# Récupération du mois correspondant
df.month = month.(df.date)
# Fréquence d'écoute par mois
df_freq = combine(
    groupby(df, :month),
    nrow => :nb_titles, 
    :ms_played => (x -> sum(x) / 60000) => :freq
)
# Ajoute des mois vides
months = DataFrame(month = 1:12)
df_freq = leftjoin(months, df_freq, on = :month)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq
```
```julia (editor=true, logging=false, output=true)
# correspondance mois
month_labels = ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"]

# préparer les données
df_data = sort(df_freq, :month)
months_str = month_labels[df_data.month]
freq = df_data.freq

# plot
fig = Figure(size=(1000, 450))
ax = Axis(
    fig[1, 1],
    xticks = (1:12, months_str),
    xlabel = "Mois",
    ylabel = "Durée d'écoute (minutes)"
)

barplot!(ax, 1:12, freq, color = "#2a2781")

fig
```
Note : changer le nombre de chanson écoutées en le nombre de minutes de musique ?

## 2. Répartition sur les jours de la semaine (bar chart)

```julia (editor=true, logging=false, output=true)
# Récupération du jour correspondant
df.dayofweek = dayofweek.(df.date)
# Fréquence d'écoute par mois
df_freq = combine(
    groupby(df, :dayofweek),
    nrow => :nb_titles,  # Nombre de titres écoutés
    :ms_played => (x -> sum(x) / 60000) => :freq  # Durée totale en minutes
)
# Ajoute des jours vides
days = DataFrame(dayofweek = 1:7)
df_freq = leftjoin(days, df_freq, on = :dayofweek)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq
```
```julia (editor=true, logging=false, output=true)
# Tri des données
df_data = sort(df_freq, :dayofweek)
days_str = day_labels[df_data.dayofweek]
freq = df_data.freq

# plot
fig = Figure(size=(800, 450))
ax = Axis(
    fig[1, 1],
    xticks = (1:7, days_str),
    xlabel = "Jour de la semaine",
    ylabel = "Nombre de chasons écoutées"
)

barplot!(ax, 1:7, freq)
```
## 3. Répartition sur les heures de la journée

```julia (editor=true, logging=false, output=true)
# Tranche horaire de chaque écoute
df.hour = hour.(df.time)
# Fréquence d'écoute par heure
df_freq = combine(
    groupby(df, :hour),
    nrow => :freq
)
# Ajoute des heures vides
hours = DataFrame(hour = 0:23)
df_freq = leftjoin(hours, df_freq, on = :hour)
df_freq.freq .= coalesce.(df_freq.freq, 0)

# Rose des vents
df_freq |>
@vlplot(
    width = 400,
    height = 400,
    mark = {
        :arc,
        innerRadius = 20,
        stroke = "white"
    },
    encoding = {
        theta = {
            field = :hour,
            type = :quantitative,
            scale = {
                domain = [0, 24],
                range = [π/2, 5π/2]   # 0h en haut
            }
        },
        radius = {
            field = :freq,
            type = :quantitative,
            title = "Fréquence d'écoute"
        },
        color = {
            field = :hour,
            type = :quantitative,
            scale = {scheme = "turbo"},
            legend = nothing
        },
        tooltip = [
            {field = :hour, type = :quantitative, title = "Heure"},
            {field = :freq, type = :quantitative, title = "Écoutes"}
        ]
    },
    config = {
        view = {stroke = nothing}
    }
)
```
```julia (editor=true, logging=false, output=true)
# Tranche horaire de chaque écoute
df.hour = hour.(df.time)
# Fréquence d'écoute par heure
df_freq = combine(
    groupby(df, :hour),
    nrow => :freq
)
# Dataframe heures + nombre de chansons jouées
hours = DataFrame(hour = 0:23)
df_freq = leftjoin(hours, df_freq, on = :hour)
df_freq.freq .= coalesce.(df_freq.freq, 0)
```
```julia (editor=true, logging=false, output=true)
using DataFrames
using GLMakie

function spiderplot(df_freq::DataFrame; labelcol::Symbol=:hour, valcol::Symbol=:freq,
                    close_polygon::Bool=true, rmax=nothing)

    # ordonne les valeurs
    df = sort(df_freq, labelcol, rev=true)
    labels = string.(df[!, labelcol])
    r = Float64.(df[!, valcol])

    n = length(r)

    # angles (n points) + rotation pour avoir 0 en haut
    rotation=π/2+π/12
    θ = collect(range(0, 2π; length=n+1))[1:end-1] .+ rotation

    # fermer le polygone
    if close_polygon
        θ = vcat(θ, θ[1])
        r = vcat(r, r[1])
    end

    rmax_val = isnothing(rmax) ? maximum(r) : rmax

    fig = Figure(size=(700, 600))
    ax = Axis(fig[1, 1], aspect=DataAspect())
    hidedecorations!(ax); hidespines!(ax)

    # grille radiale (5 cercles)
    for rr in range(0, rmax_val; length=6)[2:end]
        tt = range(0, 2π; length=400)
        lines!(ax, rr .* cos.(tt), rr .* sin.(tt))
    end

    # rayons
    for t in (collect(range(0, 2π; length=n+1))[1:end-1] .+ rotation)
        lines!(ax, [0, rmax_val*cos(t)], [0, rmax_val*sin(t)])
    end

    # polygone
    x = r .* cos.(θ)
    y = r .* sin.(θ)
    poly!(ax, Point2f.(x, y), strokewidth=3)
    scatter!(ax, x, y)

    # labels
    θlab = (collect(range(0, 2π; length=n+1))[1:end-1] .+ rotation)
    for (i, t) in enumerate(θlab)
        tx = 1.08 * rmax_val * cos(t)
        ty = 1.08 * rmax_val * sin(t)
        text!(ax, labels[i], position=Point2f(tx, ty), align=(:center, :center))
    end

    fig
end


fig = spiderplot(df_freq; labelcol=:hour, valcol=:freq)
fig

```
J'ai pas réussi à obtenir mieux pour le moment (oui c'est très moche).

# Statistiques sur les titres

## 1. Nombre de titres écoutés

```julia (editor=true, logging=false, output=true)
printstyled("Vous avez écouté $(length(df.track_name)) chansons.")
```
## 2. Nombre de titres uniques écoutés

```julia (editor=true, logging=false, output=true)
printstyled("Vous avez écouté $(length(unique(df.track_name))) chansons différentes.")

```
## 3. Top écoute (annuel et mensuel avec bubble chart)

```julia (editor=true, logging=false, output=true)
#compter pour chaque titre le nombre d'écoutes
df_counts = combine(groupby(df, :track_name), nrow => :count)
#trier par nombre d'écoutes décroissant
sort!(df_counts, :count, rev=true)
#sélectionner les 10 titres les plus écoutés
top10 = df_counts[1:10, :]
```
```julia (editor=true, logging=false, output=true)
# Données
n = 10 # Nombre de musiques
top10.x = rand(n)
top10.y = rand(n)
positions = Point2f.(top10.x, top10.y)
sizes = top10.count .* 2  # Tailles des bulles
colors = rand(n)
labels = top10.track_name  # Textes à afficher
labels = coalesce.(top10.track_name, "")


# Bubble plot
fig = Figure(resolution = (800, 600))
ax = Axis(
    fig[1, 1],
    title = "Top musiques",
    xlabel = "",
    ylabel = ""
)
scatter!(
    ax,
    positions;
    markersize = sizes,
    color = colors,
    colormap = :viridis,
    strokewidth = 0.8,
    strokecolor = :black
)
text!(
    ax,
    positions;
    text = labels,
    font = "bold",
    align = (:center, :center),
    fontsize = 12,
    color = :black
)
fig

```
Pas d'anti-chevauchement propre avec Makie.

```julia (editor=true, logging=false, output=true)
# Données
n = 10 # Nombre de musiques
top10.x = rand(n)
top10.y = rand(n)
# Figure
top10 |>
@vlplot(
    width = 600,
    height = 400,
    title = "Bubble plot (VegaLite)",
    layer = [
        {
            mark = { :circle, stroke = "black", strokeWidth = 1 },
            x = :x,
            y = :y,
            size = {
                :count,
                scale = {range = [200, 2500]}
            },
            color = {
                :count,
                scale = { scheme = "viridis" }
            }
        },
        {
            mark = {
                :text,
                align = "center",
                baseline = "middle",
                fontSize = 12
            },
            x = :x,
            y = :y,
            text = :track_name
        }
    ]
)

```
# Statistiques sur les artistes

## 1. Nombre d'artistes écoutés

```julia (editor=true, logging=false, output=true)

printstyled("Vous avez écouté $(length(unique(df.artist))) artistes différents.")
```
## 2. Top artistes (annuel et mensuel avec bubble chart)

Nombre de titres écoutés par artiste

```julia (editor=true, logging=false, output=true)
#compter pour chaque artiste le nombre d'écoutes
df_artist_counts = combine(groupby(df, :artist), nrow => :count)
#trier par nombre d'écoutes décroissant
sort!(df_artist_counts, :count, rev=true)
#sélectionner les 10 artistes les plus écoutés
top10_artists = df_artist_counts[1:10, :]
```
Variante Top artistes par temps d'écoute (en minutes)

```julia (editor=true, logging=false, output=true)
top10_artists_time =
    combine(groupby(df, :artist),
            :ms_played => sum => :total_time) |>
    df -> transform(df, :total_time => ByRow(x -> x / 60000) => :total_time_min) |>
    df -> sort(df, :total_time_min, rev = true) |>
    df -> df[1:10, :]
top10_artists_time
```
