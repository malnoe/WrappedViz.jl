# Vrac des idÃ©es pour le rendu final
```julia (editor=true, logging=false, output=true)
using Makie, WGLMakie, Gtk, JSON3, DataFrames, Dates, VegaLite, GLMakie

# Dialogue sÃ©lection du fichier
#file_path = open_dialog("SÃ©lectionnez un fichier Spotify (JSON)")
#file_path === nothing && error("Aucun fichier sÃ©lectionnÃ©.")
# Lecture fichier
#txt = read(file_path, String)
#txt = strip(txt)
txt = "examples/data/History_files/Streaming_History_Audio_2024-2025_2.json"
# Parse JSON
data = JSON3.read(txt)
# Conversion en dataframe
rows = [Dict{Symbol,Any}(Symbol(k) => v for (k, v) in pairs(obj)) for obj in data]
df = DataFrame(rows)

# SÃ©paration de la date et de l'heure
# Conversion en DateTime
df.date_time_parsed = DateTime.(df.ts, dateformat"yyyy-mm-ddTHH:MM:SSZ")
# SÃ©paration en deux colonnes
df.date = Date.(df.date_time_parsed)
df.time = Time.(df.date_time_parsed)

first(df,2)
```
```julia (editor=true, logging=false, output=true)
df = select(df, 
:master_metadata_track_name => :track_name, 
:master_metadata_album_album_name => :album,
:master_metadata_album_artist_name => :artist,
:date, :time,
:ms_played,
:skipped,
:reason_end,
:shuffle
)
first(df, 2)
```
# Temps d'Ã©coute

## 0. Statistiques globales (minutes, heures, jours) (KPI)

```julia (editor=true, logging=false, output=true)
tps_min = sum(df.ms_played) / 60000  # en minutes
tps_h = tps_min / 60
tps_j = tps_h / 24

printstyled("Vous avez $(round(tps_min, digits = 2)) minutes d'Ã©coute, soit $(round(tps_h, digits = 2)) heures, ou $(round(tps_j)) jours. Waouh !")
```
```julia (editor=false, logging=false, output=true)
printstyled("Vous avez Ã©coutÃ© de la musiques pendant $(round(tps_min,digits=0)) minutes, soit $(round(tps_h,digits=0)) heures ou $(round(tps_j,digits=0)) jours !")
```
## 1. RÃ©partition sur les mois (bar chart)

```julia (editor=true, logging=false, output=true)
# RÃ©cupÃ©ration du mois correspondant
df.month = month.(df.date)
# FrÃ©quence d'Ã©coute par mois
df_freq = combine(
    groupby(df, :month),
    nrow => :nb_titles, 
    :ms_played => (x -> sum(x) / 60000) => :freq
)
# Ajoute des mois vides
months = DataFrame(month = 1:12)
df_freq = leftjoin(months, df_freq, on = :month)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq
```
```julia (editor=true, logging=false, output=true)
# correspondance mois
month_labels = ["Janvier", "FÃ©vrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "AoÃ»t", "Septembre", "Octobre", "Novembre", "DÃ©cembre"]

# prÃ©parer les donnÃ©es
df_data = sort(df_freq, :month)
months_str = month_labels[df_data.month]
freq = df_data.freq

# plot
fig = Figure(size=(1000, 450))
ax = Axis(
    fig[1, 1],
    xticks = (1:12, months_str),
    xlabel = "Mois",
    ylabel = "DurÃ©e d'Ã©coute (minutes)"
)

barplot!(ax, 1:12, freq, color = "#2a2781")

fig
```
```julia (editor=true, logging=false, output=true)
# Fonction associÃ©e au graphique prÃ©cÃ©dent
function bp_monthly_tracks(df::DataFrame)
    # RÃ©cupÃ©ration du mois correspondant
    df.month = month.(df.date)
    # FrÃ©quence d'Ã©coute par mois
    df_freq = combine(
        groupby(df, :month),
        nrow => :nb_titles,  # Nombre de titres Ã©coutÃ©s
        :ms_played => (x -> sum(x) ./ 60000) => :freq  # DurÃ©e totale en minutes
    )
    # Ajoute des mois vides
    months = DataFrame(month = 1:12)
    df_freq = leftjoin(months, df_freq, on = :month)
    df_freq.freq .= coalesce.(df_freq.freq, 0)
    df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
    # Correspondance mois
    month_labels = [
        "Janvier", "FÃ©vrier", "Mars", "Avril", "Mai", "Juin", 
        "Juillet", "AoÃ»t", "Septembre", "Octobre", "Novembre", "DÃ©cembre"
    ]
    # Tri des donÃ©es
    df_data = sort(df_freq, :month)
    months_str = month_labels[df_data.month]
    freq = df_data.freq
    # Meilleur mois
    best_month_idx = findmax(freq)[2]
    printstyled(
        "Tu as fait fort en $(months_str[best_month_idx]) avec $(round(freq[best_month_idx], digits=2)) minutes d'Ã©coute ! ðŸ¤¯",
        bold = true, color = :magenta
    )
    # Barplot
    fig = Figure(size=(1000, 450))
    ax = Axis(
        fig[1, 1],
        xticks = (1:12, months_str),
        xlabel = "Mois",
        ylabel = "DurÃ©e d'Ã©coute (minutes)"
    )
    barplot!(ax, 1:12, freq, color = "#2a2781")
    fig
end
```
```julia (editor=true, logging=false, output=true)
bp_monthly_tracks(df)
```
Note : changer le nombre de chanson Ã©coutÃ©es en le nombre de minutes de musique ?

## 2. RÃ©partition sur les jours de la semaine (bar chart)

```julia (editor=true, logging=false, output=true)
# RÃ©cupÃ©ration du jour correspondant
df.dayofweek = dayofweek.(df.date)
# FrÃ©quence d'Ã©coute par mois
df_freq = combine(
    groupby(df, :dayofweek),
    nrow => :nb_titles,  # Nombre de titres Ã©coutÃ©s
    :ms_played => (x -> sum(x) ./ (60000 .* 52)) => :freq  # DurÃ©e totale moyenne en minutes
)
# Conversion en nombre de titre moyens
df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
# Ajoute des jours vides
days = DataFrame(dayofweek = 1:7)
df_freq = leftjoin(days, df_freq, on = :dayofweek)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq
```
```julia (editor=true, logging=false, output=true)
# correspondance jour de la semaine
day_labels = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"]
# Tri des donnÃ©es
df_data = sort(df_freq, :dayofweek)
days_str = day_labels[df_data.dayofweek]
freq = df_data.freq
# Meilleur jour
best_day_idx = findmax(freq)[2]
best_month = printstyled(
    "$(days_str[best_day_idx]) est ton jour musical de la semaine : tu Ã©coutes en moyenne $(round(freq[best_day_idx], digits=2)) minutes de musique ! ðŸ¤¯",
    bold = true, color = :magenta
)
# plot
fig = Figure(size=(800, 450))
ax = Axis(
    fig[1, 1],
    xticks = (1:7, days_str),
    xlabel = "Jour de la semaine",
    ylabel = "DurÃ©e d'Ã©coute moyenne (minutes)"
)

barplot!(ax, 1:7, freq)

fig
barplot!(ax, 1:7, freq, color = "#2a2781")
fig
```
```julia (editor=true, logging=false, output=true)
# fonction associÃ©e au graphique prÃ©cÃ©dent
function bp_daily_tracks(df::DataFrame)
    # RÃ©cupÃ©ration du jour correspondant
    df.dayofweek = dayofweek.(df.date)
    # FrÃ©quence d'Ã©coute par mois
    df_freq = combine(
        groupby(df, :dayofweek),
        nrow => :nb_titles,  # Nombre de titres Ã©coutÃ©s
        :ms_played => (x -> sum(x) ./ (60000 .* 52)) => :freq  # DurÃ©e totale moyenne en minutes
    )
    # Conversion en nombre de titre moyens
    df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
    # Ajoute des jours vides
    days = DataFrame(dayofweek = 1:7)
    df_freq = leftjoin(days, df_freq, on = :dayofweek)
    df_freq.freq .= coalesce.(df_freq.freq, 0)
    df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
    # correspondance jour de la semaine
    day_labels = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"]
    # Tri des donnÃ©es
    df_data = sort(df_freq, :dayofweek)
    days_str = day_labels[df_data.dayofweek]
    freq = df_data.freq
    # Meilleur jour
    best_day_idx = findmax(freq)[2]
    printstyled(
        "$(days_str[best_day_idx]) est ton jour musical de la semaine : tu Ã©coutes en moyenne $(round(freq[best_day_idx], digits=2)) \nminutes de musique ! ðŸ¤¯",
        bold = true, color = :magenta
    )
    # plot
    fig = Figure(size=(800, 450))
    ax = Axis(
        fig[1, 1],
        xticks = (1:7, days_str),
        xlabel = "Jour de la semaine",
        ylabel = "DurÃ©e d'Ã©coute moyenne (minutes)"
    )
    barplot!(ax, 1:7, freq, color = "#2a2781")
    fig
end
```
```julia (editor=true, logging=false, output=true)
bp_daily_tracks(df)
```
## 3. RÃ©partition sur les heures de la journÃ©e

```julia (editor=true, logging=false, output=true)
# Tranche horaire de chaque Ã©coute
df.hour = hour.(df.time)
# FrÃ©quence d'Ã©coute par heure
df_freq = combine(
    groupby(df, :hour),
    nrow => :freq
)
# Ajoute des heures vides
hours = DataFrame(hour = 0:23)
df_freq = leftjoin(hours, df_freq, on = :hour)
df_freq.freq .= coalesce.(df_freq.freq, 0)

# Rose des vents
df_freq |>
@vlplot(
    width = 400,
    height = 400,
    mark = {
        :arc,
        innerRadius = 20,
        stroke = "white"
    },
    encoding = {
        theta = {
            field = :hour,
            type = :quantitative,
            scale = {
                domain = [0, 24],
                range = [Ï€/2, 5Ï€/2]   # 0h en haut
            }
        },
        radius = {
            field = :freq,
            type = :quantitative,
            title = "FrÃ©quence d'Ã©coute"
        },
        color = {
            field = :hour,
            type = :quantitative,
            scale = {scheme = "turbo"},
            legend = nothing
        },
        tooltip = [
            {field = :hour, type = :quantitative, title = "Heure"},
            {field = :freq, type = :quantitative, title = "Ã‰coutes"}
        ]
    },
    config = {
        view = {stroke = nothing}
    }
)
```
```julia (editor=true, logging=false, output=true)
# Tranche horaire de chaque Ã©coute
df.hour = hour.(df.time)
# FrÃ©quence d'Ã©coute par heure
df_freq = combine(
    groupby(df, :hour),
    nrow => :nb_titles,  # Nombre de titres Ã©coutÃ©s
    :ms_played => (x -> round.(sum(x) ./ (60000 .* 52), digits = 2)) => :freq  # DurÃ©e totale moyenne en minutes
)
# Conversion en nombre de titre moyens par heures
df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
# Ajout des heurs creuses
hours = DataFrame(hour = 0:23)
df_freq = leftjoin(hours, df_freq, on = :hour)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq

# Tri des donnÃ©es
df_data = sort(df_freq, :hour, rev=true)
labels = string.(df_data[!, :hour])
freq = df_data.freq
# Meilleur heure
best_hour_idx = findmax(freq)[2]
printstyled(
    "Waouh ! $(df_data[best_hour_idx, :hour])h est vraiment ton heure d'Ã©coute ! ðŸ”¥",
    bold = true, color = :magenta
)
df_data
```
```julia (editor=true, logging=false, output=true)
using DataFrames
using GLMakie

function spiderplot(df_freq::DataFrame; labelcol::Symbol=:hour, valcol::Symbol=:freq, close_polygon::Bool=true, rmax=nothing)

    # ordonne les valeurs
    df_data = sort(df_freq, labelcol, rev=true)
    labels = string.(df_data[!, labelcol])
    r = Float64.(df_data[!, valcol])

    n = length(r)

    # angles (n points) + rotation pour avoir 0 en haut
    rotation=Ï€/2+Ï€/12
    Î¸ = collect(range(0, 2Ï€; length=n+1))[1:end-1] .+ rotation

    # fermer le polygone
    if close_polygon
        Î¸ = vcat(Î¸, Î¸[1])
        r = vcat(r, r[1])
    end

    rmax_val = isnothing(rmax) ? maximum(r) : rmax

    fig = Figure(size=(700, 600))
    ax = Axis(fig[1, 1], aspect=DataAspect())
    hidedecorations!(ax); hidespines!(ax)

    # grille radiale (5 cercles)
    for rr in range(0, rmax_val; length=6)[2:end]
        tt = range(0, 2Ï€; length=400)
        lines!(ax, rr .* cos.(tt), rr .* sin.(tt))
    end

    # rayons
    for t in (collect(range(0, 2Ï€; length=n+1))[1:end-1] .+ rotation)
        lines!(ax, [0, rmax_val*cos(t)], [0, rmax_val*sin(t)])
    end

    # polygone
    x = r .* cos.(Î¸)
    y = r .* sin.(Î¸)
    poly!(ax, Point2f.(x, y), strokewidth=3)
    scatter!(ax, x, y)

    # labels
    Î¸lab = (collect(range(0, 2Ï€; length=n+1))[1:end-1] .+ rotation)
    for (i, t) in enumerate(Î¸lab)
        tx = 1.08 * rmax_val * cos(t)
        ty = 1.08 * rmax_val * sin(t)
        text!(ax, labels[i], position=Point2f(tx, ty), align=(:center, :center))
    end

    fig
end


fig = spiderplot(df_freq; labelcol=:hour, valcol=:freq)
fig

```
```julia (editor=true, logging=false, output=true)
# Fonction associÃ©e Ã  la figure prÃ©cÃ©dente
function windrose_hourly_tracks(df::DataFrame; close_polygon::Bool=true, rmax=nothing)
    # Tranche horaire de chaque Ã©coute
    df.hour = hour.(df.time)
    # FrÃ©quence d'Ã©coute par heure
    df_freq = combine(
        groupby(df, :hour),
        nrow => :nb_titles,  # Nombre de titres Ã©coutÃ©s
        :ms_played => (x -> round.(sum(x) ./ (60000 .* 52), digits = 2)) => :freq  # DurÃ©e totale moyenne en minutes
    )
    # Conversion en nombre de titre moyens par heures
    df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
    # Ajout des heurs creuses
    hours = DataFrame(hour = 0:23)
    df_freq = leftjoin(hours, df_freq, on = :hour)
    df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
    df_freq.freq .= coalesce.(df_freq.freq, 0)
    # Tri des donnÃ©es
    df_data = sort(df_freq, :hour, rev=true)
    labels = string.(df_data[!, :hour])
    # Meilleur heure
    best_hour_idx = findmax(df_data.freq)[2]
    printstyled(
        "Waouh ! $(df_data[best_hour_idx, :hour])h est vraiment ton heure d'Ã©coute ! ðŸ”¥",
        bold = true, color = :magenta
    )
    # RÃ©glages de la figure
    r = Float64.(df_data[!, :freq])
    n = length(r)
    # Angles (n points) + rotation pour avoir 0 en haut
    rotation = Ï€/2 + Ï€/12
    Î¸ = collect(range(0, 2Ï€; length=n+1))[1:end-1] .+ rotation
    # Fermer le polygone
    if close_polygon
        Î¸ = vcat(Î¸, Î¸[1])
        r = vcat(r, r[1])
    end
    rmax_val = isnothing(rmax) ? maximum(r) : rmax
    # Figure
    fig = Figure(size=(700, 600))
    ax = Axis(fig[1, 1], aspect=DataAspect())
    hidedecorations!(ax); hidespines!(ax)
    ### grille radiale (5 cercles) avec dÃ©gradÃ© de couleurs
    rrs = range(0, rmax_val; length=6)[2:end]
    for rr in rrs
        tt = range(0, 2Ï€; length=400)
        lines!(
            ax, rr .* cos.(tt), rr .* sin.(tt),
            color = rr,  colormap = :YlOrRd, colorrange = (0, rmax_val),
            linewidth = 1.5
        )
    end
    ### Rayons
    for t in (collect(range(0, 2Ï€; length=n+1))[1:end-1] .+ rotation)
        lines!(ax, [0, rmax_val*cos(t)], [0, rmax_val*sin(t)],
        color=:black, linestyle=:dot
        )
    end
    ### Polygone
    x = r .* cos.(Î¸)
    y = r .* sin.(Î¸)
    poly!(ax, Point2f.(x, y), strokewidth=2, color=("#2a2781", 0.8), strokecolor="#2a2781")
    # scatter!(ax, x, y, marker=:star4, color="#2a2781")
    ### labels
    Î¸lab = (collect(range(0, 2Ï€; length=n+1))[1:end-1] .+ rotation)
    for (i, t) in enumerate(Î¸lab)
        tx = 1.08 * rmax_val * cos(t)
        ty = 1.08 * rmax_val * sin(t)
        text!(ax, labels[i], position=Point2f(tx, ty), align=(:center, :center))
    end
    fig
end
```
```julia (editor=true, logging=false, output=true)
windrose_hourly_tracks(df)
```
```julia (editor=true, logging=false, output=true)
printstyled("Vous avez Ã©coutÃ© $(length(df.track_name)) chansons.")
```
## 2. Nombre de titres uniques Ã©coutÃ©s

```julia (editor=true, logging=false, output=true)
printstyled("Vous avez Ã©coutÃ© $(length(unique(df.track_name))) chansons diffÃ©rentes.")

```
## 3. Top Ã©coute (annuel et mensuel avec bubble chart)

```julia (editor=true, logging=false, output=true)
#compter pour chaque titre le nombre d'Ã©coutes
df_counts = combine(groupby(df, :track_name), nrow => :count)
#trier par nombre d'Ã©coutes dÃ©croissant
sort!(df_counts, :count, rev=true)
#sÃ©lectionner les 10 titres les plus Ã©coutÃ©s
top10 = df_counts[1:10, :]
```
```julia (editor=true, logging=false, output=true)
# DonnÃ©es
n = 10 # Nombre de musiques
top10.x = rand(n)
top10.y = rand(n)
positions = Point2f.(top10.x, top10.y)
sizes = top10.count .* 2  # Tailles des bulles
colors = rand(n)
labels = top10.track_name  # Textes Ã  afficher
labels = coalesce.(top10.track_name, "")


# Bubble plot
fig = Figure(resolution = (800, 600))
ax = Axis(
    fig[1, 1],
    title = "Top musiques",
    xlabel = "",
    ylabel = ""
)
scatter!(
    ax,
    positions;
    markersize = sizes,
    color = colors,
    colormap = :viridis,
    strokewidth = 0.8,
    strokecolor = :black
)
text!(
    ax,
    positions;
    text = labels,
    font = "bold",
    align = (:center, :center),
    fontsize = 12,
    color = :black
)
fig

```
```julia (editor=true, logging=false, output=true)
function bbplot_tracks(df::DataFrame)
    # Phrases d'intro
    printstyled(
        "Tu as Ã©coutÃ© $(length(df.track_name)) titres, dont $(length(unique(df.track_name))) diffÃ©rents. ImprÃ©ssionnant ! \nMais certains titres ton plus marquÃ©, regarde ðŸ‘‡", 
        bold=true, color=:magenta
    )
    # Nombre d'Ã©coutes par artistes
    df_counts = combine(groupby(df, :track_name), nrow => :listening_counts)
    # Trier par ordre dÃ©croissant
    sort!(df_counts, :listening_counts, rev=true)
    # Top 10 titres les plus Ã©coutÃ©s
    top10 = df_counts[1:10, :]
    # DonnÃ©es graphiques
    ### Positions des bulles
    top10.x = rand(10)
    top10.y = rand(10)
    positions = Point2f.(top10.x, top10.y)
    ### Taille des bulles
    bb_sizes = top10.listening_counts .* 2
    ### Couleur et noms des bulles
    bb_colors = rand(10)
    bb_labels = top10.track_name  # Textes Ã  afficher
    bb_labels = coalesce.(top10.track_name, "")
    # Bubble plot
    fig = Figure(resolution = (800, 600))
    ax = Axis(
        fig[1, 1],
        title = "Top 10 titres", xlabel = "", ylabel = ""
    )
    scatter!(
        ax, positions;
        markersize = bB_sizes,
        color = bb_colors, colormap = :viridis,
        strokewidth = 0.8,
        strokecolor = :black
    )
    text!(
        ax,
        positions;
        text = bb_labels,
        font = "bold",
        align = (:center, :center),
        fontsize = 12,
        color = :black
    )
    fig
end
```
```julia (editor=true, logging=false, output=true)
bbplot_tracks(df)
```
Pas d'anti-chevauchement propre avec Makie.

```julia (editor=true, logging=false, output=true)
# DonnÃ©es
n = 10 # Nombre de musiques
top10.x = rand(n)
top10.y = rand(n)
# Figure
top10 |>
@vlplot(
    width = 600,
    height = 400,
    title = "Bubble plot (VegaLite)",
    layer = [
        {
            mark = { :circle, stroke = "black", strokeWidth = 1 },
            x = :x,
            y = :y,
            size = {
                :count,
                scale = {range = [200, 2500]}
            },
            color = {
                :count,
                scale = { scheme = "viridis" }
            }
        },
        {
            mark = {
                :text,
                align = "center",
                baseline = "middle",
                fontSize = 12
            },
            x = :x,
            y = :y,
            text = :track_name
        }
    ]
)

```
# Statistiques sur les artistes

## 1. Nombre d'artistes Ã©coutÃ©s

```julia (editor=true, logging=false, output=true)

printstyled("Vous avez Ã©coutÃ© $(length(unique(df.artist))) artistes diffÃ©rents.")
```
## 2. Top artistes (annuel et mensuel avec bubble chart)

Nombre de titres Ã©coutÃ©s par artiste

```julia (editor=true, logging=false, output=true)
#compter pour chaque artiste le nombre d'Ã©coutes
df_artist_counts = combine(groupby(df, :artist), nrow => :count)
#trier par nombre d'Ã©coutes dÃ©croissant
sort!(df_artist_counts, :count, rev=true)
#sÃ©lectionner les 10 artistes les plus Ã©coutÃ©s
top10_artists = df_artist_counts[1:10, :]
```
Variante Top artistes par temps d'Ã©coute (en minutes)

```julia (editor=true, logging=false, output=true)
top10_artists_time =
    combine(groupby(df, :artist),
            :ms_played => sum => :total_time) |>
    df -> transform(df, :total_time => ByRow(x -> x / 60000) => :total_time_min) |>
    df -> sort(df, :total_time_min, rev = true) |>
    df -> df[1:10, :]
top10_artists_time
```
