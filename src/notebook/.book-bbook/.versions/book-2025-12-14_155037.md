# Vrac des id√©es pour le rendu final

```julia (editor=true, logging=false, output=true)
using Makie, WGLMakie, Gtk, JSON3, DataFrames, Dates, VegaLite, GLMakie

# Dialogue s√©lection du fichier
#file_path = open_dialog("S√©lectionnez un fichier Spotify (JSON)")
#file_path === nothing && error("Aucun fichier s√©lectionn√©.")
# Lecture fichier
#txt = read(file_path, String)
#txt = strip(txt)
txt = "examples/data/History_files/Streaming_History_Audio_2024-2025_2.json"
# Parse JSON
data = JSON3.read(txt)
# Conversion en dataframe
rows = [Dict{Symbol,Any}(Symbol(k) => v for (k, v) in pairs(obj)) for obj in data]
df = DataFrame(rows)

# S√©paration de la date et de l'heure
# Conversion en DateTime
df.date_time_parsed = DateTime.(df.ts, dateformat"yyyy-mm-ddTHH:MM:SSZ")
# S√©paration en deux colonnes
df.date = Date.(df.date_time_parsed)
df.time = Time.(df.date_time_parsed)

first(df,2)
```
```julia (editor=true, logging=false, output=true)
df = select(df, 
:master_metadata_track_name => :track_name, 
:master_metadata_album_album_name => :album,
:master_metadata_album_artist_name => :artist,
:date, :time,
:ms_played,
:skipped,
:reason_end,
:shuffle
)
first(df, 2)
```
# Temps d'√©coute

## 0. Statistiques globales (minutes, heures, jours) (KPI)

```julia (editor=true, logging=false, output=true)
tps_min = sum(df.ms_played) / 60000  # en minutes
tps_h = tps_min / 60
tps_j = tps_h / 24

printstyled("Vous avez $(round(tps_min, digits = 2)) minutes d'√©coute, soit $(round(tps_h, digits = 2)) heures, ou $(round(tps_j)) jours. Waouh !")
```
```julia (editor=false, logging=false, output=true)
printstyled("Vous avez √©cout√© de la musiques pendant $(round(tps_min,digits=0)) minutes, soit $(round(tps_h,digits=0)) heures ou $(round(tps_j,digits=0)) jours !")
```
## 1. R√©partition sur les mois (bar chart)

```julia (editor=true, logging=false, output=true)
# R√©cup√©ration du mois correspondant
df.month = month.(df.date)
# Fr√©quence d'√©coute par mois
df_freq = combine(
    groupby(df, :month),
    nrow => :nb_titles, 
    :ms_played => (x -> sum(x) / 60000) => :freq
)
# Ajoute des mois vides
months = DataFrame(month = 1:12)
df_freq = leftjoin(months, df_freq, on = :month)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq
```
```julia (editor=true, logging=false, output=true)
# correspondance mois
month_labels = ["Janvier", "F√©vrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Ao√ªt", "Septembre", "Octobre", "Novembre", "D√©cembre"]

# pr√©parer les donn√©es
df_data = sort(df_freq, :month)
months_str = month_labels[df_data.month]
freq = df_data.freq

# plot
fig = Figure(size=(1000, 450))
ax = Axis(
    fig[1, 1],
    xticks = (1:12, months_str),
    xlabel = "Mois",
    ylabel = "Dur√©e d'√©coute (minutes)"
)

barplot!(ax, 1:12, freq, color = "#2a2781")

fig
```
```julia (editor=true, logging=false, output=true)
# Fonction associ√©e au graphique pr√©c√©dent
function bp_monthly_tracks(df::DataFrame)
    # R√©cup√©ration du mois correspondant
    df.month = month.(df.date)
    # Fr√©quence d'√©coute par mois
    df_freq = combine(
        groupby(df, :month),
        nrow => :nb_titles,  # Nombre de titres √©cout√©s
        :ms_played => (x -> sum(x) ./ 60000) => :freq  # Dur√©e totale en minutes
    )
    # Ajoute des mois vides
    months = DataFrame(month = 1:12)
    df_freq = leftjoin(months, df_freq, on = :month)
    df_freq.freq .= coalesce.(df_freq.freq, 0)
    df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
    # Correspondance mois
    month_labels = [
        "Janvier", "F√©vrier", "Mars", "Avril", "Mai", "Juin", 
        "Juillet", "Ao√ªt", "Septembre", "Octobre", "Novembre", "D√©cembre"
    ]
    # Tri des don√©es
    df_data = sort(df_freq, :month)
    months_str = month_labels[df_data.month]
    freq = df_data.freq
    # Meilleur mois
    best_month_idx = findmax(freq)[2]
    printstyled(
        "Tu as fait fort en $(months_str[best_month_idx]) avec $(round(freq[best_month_idx], digits=2)) minutes d'√©coute ! ü§Ø",
        bold = true, color = :magenta
    )
    # Barplot
    fig = Figure(size=(1000, 450))
    ax = Axis(
        fig[1, 1],
        xticks = (1:12, months_str),
        xlabel = "Mois",
        ylabel = "Dur√©e d'√©coute (minutes)"
    )
    barplot!(ax, 1:12, freq, color = "#2a2781")
    fig
end
```
```julia (editor=true, logging=false, output=true)
bp_monthly_tracks(df)
```
Note : changer le nombre de chanson √©cout√©es en le nombre de minutes de musique ?

## 2. R√©partition sur les jours de la semaine (bar chart)

```julia (editor=true, logging=false, output=true)
# R√©cup√©ration du jour correspondant
df.dayofweek = dayofweek.(df.date)
# Fr√©quence d'√©coute par mois
df_freq = combine(
    groupby(df, :dayofweek),
    nrow => :nb_titles,  # Nombre de titres √©cout√©s
    :ms_played => (x -> sum(x) ./ (60000 .* 52)) => :freq  # Dur√©e totale moyenne en minutes
)
# Conversion en nombre de titre moyens
df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
# Ajoute des jours vides
days = DataFrame(dayofweek = 1:7)
df_freq = leftjoin(days, df_freq, on = :dayofweek)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq
```
```julia (editor=true, logging=false, output=true)
# correspondance jour de la semaine
day_labels = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"]
# Tri des donn√©es
df_data = sort(df_freq, :dayofweek)
days_str = day_labels[df_data.dayofweek]
freq = df_data.freq
# Meilleur jour
best_day_idx = findmax(freq)[2]
best_month = printstyled(
    "$(days_str[best_day_idx]) est ton jour musical de la semaine : tu √©coutes en moyenne $(round(freq[best_day_idx], digits=2)) minutes de musique ! ü§Ø",
    bold = true, color = :magenta
)
# plot
fig = Figure(size=(800, 450))
ax = Axis(
    fig[1, 1],
    xticks = (1:7, days_str),
    xlabel = "Jour de la semaine",
    ylabel = "Dur√©e d'√©coute moyenne (minutes)"
)

barplot!(ax, 1:7, freq)

fig
barplot!(ax, 1:7, freq, color = "#2a2781")
fig
```
```julia (editor=true, logging=false, output=true)
# fonction associ√©e au graphique pr√©c√©dent
function bp_daily_tracks(df::DataFrame)
    # R√©cup√©ration du jour correspondant
    df.dayofweek = dayofweek.(df.date)
    # Fr√©quence d'√©coute par mois
    df_freq = combine(
        groupby(df, :dayofweek),
        nrow => :nb_titles,  # Nombre de titres √©cout√©s
        :ms_played => (x -> sum(x) ./ (60000 .* 52)) => :freq  # Dur√©e totale moyenne en minutes
    )
    # Conversion en nombre de titre moyens
    df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
    # Ajoute des jours vides
    days = DataFrame(dayofweek = 1:7)
    df_freq = leftjoin(days, df_freq, on = :dayofweek)
    df_freq.freq .= coalesce.(df_freq.freq, 0)
    df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
    # correspondance jour de la semaine
    day_labels = ["Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi", "Dimanche"]
    # Tri des donn√©es
    df_data = sort(df_freq, :dayofweek)
    days_str = day_labels[df_data.dayofweek]
    freq = df_data.freq
    # Meilleur jour
    best_day_idx = findmax(freq)[2]
    printstyled(
        "$(days_str[best_day_idx]) est ton jour musical de la semaine : tu √©coutes en moyenne $(round(freq[best_day_idx], digits=2)) \nminutes de musique ! ü§Ø",
        bold = true, color = :magenta
    )
    # plot
    fig = Figure(size=(800, 450))
    ax = Axis(
        fig[1, 1],
        xticks = (1:7, days_str),
        xlabel = "Jour de la semaine",
        ylabel = "Dur√©e d'√©coute moyenne (minutes)"
    )
    barplot!(ax, 1:7, freq, color = "#2a2781")
    fig
end
```
```julia (editor=true, logging=false, output=true)
bp_daily_tracks(df)
```
## 3. R√©partition sur les heures de la journ√©e

```julia (editor=true, logging=false, output=true)
# Tranche horaire de chaque √©coute
df.hour = hour.(df.time)
# Fr√©quence d'√©coute par heure
df_freq = combine(
    groupby(df, :hour),
    nrow => :nb_titles,  # Nombre de titres √©cout√©s
    :ms_played => (x -> round.(sum(x) ./ (60000 .* 52), digits = 2)) => :freq  # Dur√©e totale moyenne en minutes
)
# Conversion en nombre de titre moyens par heures
df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
# Ajout des heurs creuses
hours = DataFrame(hour = 0:23)
df_freq = leftjoin(hours, df_freq, on = :hour)
df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
df_freq.freq .= coalesce.(df_freq.freq, 0)
df_freq

# Tri des donn√©es
df_data = sort(df_freq, :hour, rev=true)
labels = string.(df_data[!, :hour])
freq = df_data.freq
# Meilleur heure
best_hour_idx = findmax(freq)[2]
printstyled(
    "Waouh ! $(df_data[best_hour_idx, :hour])h est vraiment ton heure d'√©coute ! üî•",
    bold = true, color = :magenta
)
df_data
```
```julia (editor=true, logging=false, output=true)
using DataFrames
using GLMakie

function spiderplot(df_freq::DataFrame; labelcol::Symbol=:hour, valcol::Symbol=:freq, close_polygon::Bool=true, rmax=nothing)

    # ordonne les valeurs
    df_data = sort(df_freq, labelcol, rev=true)
    labels = string.(df_data[!, labelcol])
    r = Float64.(df_data[!, valcol])

    n = length(r)

    # angles (n points) + rotation pour avoir 0 en haut
    rotation=œÄ/2+œÄ/12
    Œ∏ = collect(range(0, 2œÄ; length=n+1))[1:end-1] .+ rotation

    # fermer le polygone
    if close_polygon
        Œ∏ = vcat(Œ∏, Œ∏[1])
        r = vcat(r, r[1])
    end

    rmax_val = isnothing(rmax) ? maximum(r) : rmax

    fig = Figure(size=(700, 600))
    ax = Axis(fig[1, 1], aspect=DataAspect())
    hidedecorations!(ax); hidespines!(ax)

    # grille radiale (5 cercles)
    for rr in range(0, rmax_val; length=6)[2:end]
        tt = range(0, 2œÄ; length=400)
        lines!(ax, rr .* cos.(tt), rr .* sin.(tt))
    end

    # rayons
    for t in (collect(range(0, 2œÄ; length=n+1))[1:end-1] .+ rotation)
        lines!(ax, [0, rmax_val*cos(t)], [0, rmax_val*sin(t)])
    end

    # polygone
    x = r .* cos.(Œ∏)
    y = r .* sin.(Œ∏)
    poly!(ax, Point2f.(x, y), strokewidth=3)
    scatter!(ax, x, y)

    # labels
    Œ∏lab = (collect(range(0, 2œÄ; length=n+1))[1:end-1] .+ rotation)
    for (i, t) in enumerate(Œ∏lab)
        tx = 1.08 * rmax_val * cos(t)
        ty = 1.08 * rmax_val * sin(t)
        text!(ax, labels[i], position=Point2f(tx, ty), align=(:center, :center))
    end

    fig
end


fig = spiderplot(df_freq; labelcol=:hour, valcol=:freq)
fig

```
```julia (editor=true, logging=false, output=true)
# Fonction associ√©e √† la figure pr√©c√©dente
function windrose_hourly_tracks(df::DataFrame; close_polygon::Bool=true, rmax=nothing)
    # Tranche horaire de chaque √©coute
    df.hour = hour.(df.time)
    # Fr√©quence d'√©coute par heure
    df_freq = combine(
        groupby(df, :hour),
        nrow => :nb_titles,  # Nombre de titres √©cout√©s
        :ms_played => (x -> round.(sum(x) ./ (60000 .* 52), digits = 2)) => :freq  # Dur√©e totale moyenne en minutes
    )
    # Conversion en nombre de titre moyens par heures
    df_freq.nb_titles = round.(df_freq.nb_titles ./ 52)
    # Ajout des heurs creuses
    hours = DataFrame(hour = 0:23)
    df_freq = leftjoin(hours, df_freq, on = :hour)
    df_freq.nb_titles .= coalesce.(df_freq.nb_titles, 0)
    df_freq.freq .= coalesce.(df_freq.freq, 0)
    # Tri des donn√©es
    df_data = sort(df_freq, :hour, rev=true)
    labels = string.(df_data[!, :hour])
    # Meilleur heure
    best_hour_idx = findmax(df_data.freq)[2]
    printstyled(
        "Waouh ! $(df_data[best_hour_idx, :hour])h est vraiment ton heure d'√©coute ! üî•",
        bold = true, color = :magenta
    )
    # R√©glages de la figure
    r = Float64.(df_data[!, :freq])
    n = length(r)
    # Angles (n points) + rotation pour avoir 0 en haut
    rotation = œÄ/2 + œÄ/12
    Œ∏ = collect(range(0, 2œÄ; length=n+1))[1:end-1] .+ rotation
    # Fermer le polygone
    if close_polygon
        Œ∏ = vcat(Œ∏, Œ∏[1])
        r = vcat(r, r[1])
    end
    rmax_val = isnothing(rmax) ? maximum(r) : rmax
    # Figure
    fig = Figure(size=(700, 600))
    ax = Axis(fig[1, 1], aspect=DataAspect())
    hidedecorations!(ax); hidespines!(ax)
    ### grille radiale (5 cercles) avec d√©grad√© de couleurs
    rrs = range(0, rmax_val; length=6)[2:end]
    for rr in rrs
        tt = range(0, 2œÄ; length=400)
        lines!(
            ax, rr .* cos.(tt), rr .* sin.(tt),
            color = rr,  colormap = :YlOrRd, colorrange = (0, rmax_val),
            linewidth = 1.5
        )
    end
    ### Rayons
    for t in (collect(range(0, 2œÄ; length=n+1))[1:end-1] .+ rotation)
        lines!(ax, [0, rmax_val*cos(t)], [0, rmax_val*sin(t)],
        color=:black, linestyle=:dot
        )
    end
    ### Polygone
    x = r .* cos.(Œ∏)
    y = r .* sin.(Œ∏)
    poly!(ax, Point2f.(x, y), strokewidth=2, color=("#2a2781", 0.8), strokecolor="#2a2781")
    # scatter!(ax, x, y, marker=:star4, color="#2a2781")
    ### labels
    Œ∏lab = (collect(range(0, 2œÄ; length=n+1))[1:end-1] .+ rotation)
    for (i, t) in enumerate(Œ∏lab)
        tx = 1.08 * rmax_val * cos(t)
        ty = 1.08 * rmax_val * sin(t)
        text!(ax, labels[i], position=Point2f(tx, ty), align=(:center, :center))
    end
    fig
end
```
```julia (editor=true, logging=false, output=true)
windrose_hourly_tracks(df)
```
```julia (editor=true, logging=false, output=true)
printstyled("Vous avez √©cout√© $(length(df.track_name)) chansons.")
```
## 2. Nombre de titres uniques √©cout√©s

```julia (editor=true, logging=false, output=true)
printstyled("Vous avez √©cout√© $(length(unique(df.track_name))) chansons diff√©rentes.")

```
## 3. Top √©coute (annuel et mensuel avec bubble chart)

```julia (editor=true, logging=false, output=true)
function bbplot_tracks(df::DataFrame)
    # Phrases d'intro
    printstyled(
        "Tu as √©cout√© $(length(df.track_name)) titres, dont $(length(unique(df.track_name))) diff√©rents. Impr√©ssionnant ! \nMais certains t'ont marqu√© plus que d'autres, regarde üëá", 
        bold=true, color=:magenta
    )
    # Nombre d'√©coutes par titres
    df_counts = combine(groupby(df, :track_name), nrow => :listening_counts)
    # Trier par ordre d√©croissant
    sort!(df_counts, :listening_counts, rev=true)
    # Top 10 titres les plus √©cout√©s
    top10 = df_counts[1:10, :]
    # Donn√©es graphiques
    ### Positions des bulles (fixes dans [0;4]x[0;4])
    top10.x = [0.5, 1.5, 2.5, 3.5, 1.0, 2.0, 3.0, 0.5, 2.5, 3.5]
    top10.y = [3.5, 3.0, 3.5, 3.0, 1.5, 1.0, 1.5, 0.5, 0.5, 1.0]
    positions = Point2f.(top10.x, top10.y)
    ### Taille des bulles
    bb_sizes = top10.listening_counts / findmax(top10.listening_counts)[1]
    ### Couleur et noms des bulles
    bb_colors = rand(10)
    bb_labels = top10.track_name  # Textes √† afficher
    bb_labels = coalesce.(top10.track_name, "")
    # Figure
    fig = Figure(size = (700, 700))
    ax = Axis(
        fig[1, 1],
        title = "Top 10 titres", xlabel = "", ylabel = ""
    )
    xlims!(ax, 0, 4)
    ylims!(ax, 0, 4)
    scatter!(
        ax, positions;
        markersize = bb_sizes, markerspace = :data,
        color = bb_colors, colormap = :viridis,
        strokewidth = 0.8, strokecolor = :black
    )
    text!(
        ax, positions;
        text = bb_labels,
        font = "bold", fontsize = 12, color = :black,
        align = (:center, :center)
    )
    fig
end
```
```julia (editor=true, logging=false, output=true)
bbplot_tracks(df)
```
# Statistiques sur les artistes

## 1. Nombre d'artistes √©cout√©s

```julia (editor=true, logging=false, output=true)

printstyled("Vous avez √©cout√© $(length(unique(df.artist))) artistes diff√©rents.")
```
## 2. Top artistes (annuel et mensuel avec bubble chart)

Nombre de titres √©cout√©s par artiste

```julia (editor=true, logging=false, output=true)
function bbplot_artists(df::DataFrame)
    # Phrases d'intro
    printstyled(
        "Tu as √©cout√© $(length(df.artist)) artistes, dont $(length(unique(df.artist))) diff√©rents. Impr√©ssionnant ! \nMais certains t'ont marqu√© plus que d'autres, regarde üëá", 
        bold=true, color=:magenta
    )
    # Nombre d'√©coutes par artistes
    df_counts = combine(groupby(df, :artist), nrow => :listening_counts)
    # Trier par ordre d√©croissant
    sort!(df_counts, :listening_counts, rev=true)
    # Top 10 artistes les plus √©cout√©s
    top10 = df_counts[1:10, :]
    # Donn√©es graphiques
    ### Positions des bulles (fixes dans [0;4]x[0;4])
    top10.x = [0.5, 1.5, 2.5, 3.5, 1.0, 2.0, 3.0, 0.5, 2.5, 3.5]
    top10.y = [3.5, 3.0, 3.5, 3.0, 1.5, 1.0, 1.5, 0.5, 0.5, 1.0]
    positions = Point2f.(top10.x, top10.y)
    ### Taille des bulles
    bb_sizes = top10.listening_counts / findmax(top10.listening_counts)[1]
    ### Couleur et noms des bulles
    bb_colors = rand(10)
    bb_labels = top10.artist  # Textes √† afficher
    bb_labels = coalesce.(top10.artist, "")
    # Bubble plot
    fig = Figure(size = (800, 600))
    ax = Axis(
        fig[1, 1],
        title = "Top 10 artistes", xlabel = "", ylabel = ""
    )
    xlims!(ax, 0, 4)
    ylims!(ax, 0, 4)
    scatter!(
        ax, positions;
        markersize = bb_sizes, markerspace = :data,
        color = bb_colors, colormap = :viridis,
        strokewidth = 0.8, strokecolor = :black
    )
    text!(
        ax, positions;
        text = bb_labels,
        font = "bold", fontsize = 12, color = :black,
        align = (:center, :center)
    )
    fig
end
```
```julia (editor=true, logging=false, output=true)
bbplot_artists(df)
```
Variante Top artistes par temps d'√©coute (en minutes)

